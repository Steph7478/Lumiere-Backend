package com.lumiere.infrastructure.auth;

import java.io.BufferedReader;
import java.io.StringReader;
import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;

import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSSigner;
import com.nimbusds.jose.JWSVerifier;
import com.nimbusds.jose.crypto.RSASSASigner;
import com.nimbusds.jose.crypto.RSASSAVerifier;
import com.nimbusds.jose.jwk.RSAKey;

public class SignerProvider {

    private static final String PRIVATE_KEY_PEM = loadEnvPrivateKey();
    private static final RSAPrivateKey PRIVATE_KEY = loadPrivateKey(PRIVATE_KEY_PEM);
    private static final RSAPublicKey PUBLIC_KEY = factoryPublicKey(PRIVATE_KEY);

    private static String loadEnvPrivateKey() {
        String key = System.getProperty("PRIVATE_KEY");
        if (key == null || key.isBlank()) {
            throw new IllegalStateException("Environment variable PRIVATE_KEY is not set or empty");
        }
        key = key.replace("\\n", "\n");
        return key;

    }

    private static RSAPrivateKey loadPrivateKey(String pem) {
        try {
            StringBuilder key = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(new StringReader(pem))) {
                String line;
                boolean inKey = false;
                while ((line = reader.readLine()) != null) {
                    if (line.contains("BEGIN PRIVATE KEY")) {
                        inKey = true;
                        continue;
                    }
                    if (line.contains("END PRIVATE KEY")) {
                        inKey = false;
                        break;
                    }
                    if (inKey) {
                        key.append(line.trim());
                    }
                }
            }

            // decoding the bytes
            byte[] keyBytes = Base64.getDecoder().decode(key.toString());

            // here I store the private key in PKCS#8 format to make it easier to extract
            // metadata (like modulus, exponents, primes, etc.)
            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);

            // and here is literally like a factory of keys, i make with the details i
            // customized before
            return (RSAPrivateKey) KeyFactory.getInstance("RSA").generatePrivate(spec);

        } catch (Exception e) {
            throw new KeyLoadException("Failed to load private key", e);
        }
    }

    // public key factory
    private static RSAPublicKey factoryPublicKey(RSAPrivateKey privateKey) {
        try {
            // crt is a calc math to optimize the calcs of p, e and c
            RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey) privateKey;

            // here im generating a public key in base of the private one
            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(
                    crtKey.getModulus(),
                    crtKey.getPublicExponent());

            // and here we go again, the factory of keys!
            return (RSAPublicKey) KeyFactory.getInstance("RSA").generatePublic(publicKeySpec);

        } catch (Exception e) {
            throw new KeyLoadException("Failed to generate public key", e);
        }
    }

    // public key getting generated by private one
    public static RSAKey getPublicJWK() {
        // reforcing the alg, to not have alg=none problems
        return new RSAKey.Builder(PUBLIC_KEY)
                .keyID("auth-key-v1")
                .algorithm(JWSAlgorithm.RS256)
                .build();
    }

    // just to sign
    public static JWSSigner getSigner() {
        return new RSASSASigner(PRIVATE_KEY);
    }

    // just to verify
    public static JWSVerifier getVerifier() {
        RSASSAVerifier verifier = new RSASSAVerifier(PUBLIC_KEY);

        // extra validation to make sure only RS256 is accepted
        if (!getPublicJWK().getAlgorithm().equals(JWSAlgorithm.RS256)) {
            throw new IllegalStateException("Not allowed");
        }
        return verifier;
    }

    // custom exception case it fails
    public static class KeyLoadException extends RuntimeException {
        public KeyLoadException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
